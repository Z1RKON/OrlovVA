# Лабораторная работа 07 - Кучи

**Дата:** 22.09.2025  
**Семестр:** 3 курс, 1 семестр  
**Группа:** ПИЖ-б-о-23-2-(2)
**Дисциплина:** Алгоритмы и структуры данных  
**Студент:** Орлов Владимир Алексеевич  

## Описание проекта

Проект реализует структуру данных «куча» на основе массива, поддерживает основные операции (вставка, извлечение корня, построение кучи), алгоритм сортировки кучей (Heapsort) и приоритетную очередь. Проведён сравнительный анализ производительности операций кучи и эффективности Heapsort в сравнении с другими алгоритмами сортировки.

## Цель работы

Изучить структуру данных «куча», её свойства и применение. Освоить основные операции с кучей (добавление, извлечение корня) и алгоритм её построения. Получить практические навыки реализации кучи на основе массива. Исследовать эффективность основных операций и применение кучи для сортировки и реализации приоритетной очереди.

## Теоретическая часть
- **Куча(Heap)**: Специализированная древовидная структура данных, удовлетворяющая свойству кучи. Является полным бинарным деревом (все уровни заполнены, кроме последнего, который заполняется слева направо).
- **Свойства кучи**:
    1. Min-Heap: Значение в любом узле меньше или равно значениям его потомков. Корень — минимальный элемент.
    2. Max-Heap: Значение в любом узле больше или равно значениям его потомков. Корень — максимальный элемент.
- **Реализация**: Куча эффективно реализуется на основе массива. Для узла с индексом i:
    1. Индекс родителя: (i-1)/2
    2. Индекс левого потомка: 2*i + 1
    3. Индекс правого потомка: 2*i + 2
- **Применение**: Сортировка кучей, приоритетная очередь, алгоритм Дейкстры


## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализация структуры данных «куча» (min-heap и max-heap) на основе массива
- [x] Задача 2: Реализация основных операций и алгоритма построения кучи из массива
- [x] Задача 3: Реализация алгоритма сортировки кучей (Heapsort)
- [x] Задача 4: Реализация приоритетной очереди на основе кучи
- [x] Задача 5: Сравнение производительности сортировки кучей с другими алгоритмами


### Ключевые фрагменты кода
```python
class PriorityHeap:
    """Универсальная куча (min-heap или max-heap)."""

    def __init__(self, min_heap: bool = True) -> None:
        """
        Инициализация кучи.

        Args:
            min_heap: True для min-heap, False для max-heap.
        """
        self._elements: List[Any] = []
        self._is_min_heap = min_heap

    def retrieve_array(self) -> List[Any]:
        """
        Получение массива кучи.

        Returns:
            Внутренний массив кучи.
        """
        return self._elements.copy()

    def _has_priority(self, a: Any, b: Any) -> bool:
        """
        Сравнение элементов в зависимости от типа кучи.

        Args:
            a: Первый элемент.
            b: Второй элемент.

        Returns:
            True, если a имеет приоритет над b.
        """
        if self._is_min_heap:
            return a < b
        else:
            return a > b

    def _bubble_up(self, idx: int) -> None:
        """
        Всплытие элемента (sift-up). Сложность: O(log n).

        Args:
            idx: Индекс элемента для всплытия.
        """
        if idx == 0:
            return

        parent_idx = (idx - 1) // 2
        if self._has_priority(self._elements[idx], self._elements[parent_idx]):
            self._elements[idx], self._elements[parent_idx] = (
                self._elements[parent_idx], self._elements[idx]
            )
            self._bubble_up(parent_idx)

    def _sink_down(self, idx: int) -> None:
        """
        Погружение элемента (sift-down). Сложность: O(log n).

        Args:
            idx: Индекс элемента для погружения.
        """
        left_child = 2 * idx + 1
        right_child = 2 * idx + 2
        target_idx = idx

        if (left_child < len(self._elements) and
                self._has_priority(self._elements[left_child],
                                   self._elements[target_idx])):
            target_idx = left_child

        if (right_child < len(self._elements) and
                self._has_priority(self._elements[right_child],
                                   self._elements[target_idx])):
            target_idx = right_child

        if target_idx != idx:
            self._elements[idx], self._elements[target_idx] = (
                self._elements[target_idx], self._elements[idx]
            )
            self._sink_down(target_idx)

    def push(self, item: Any) -> None:
        """
        Вставка элемента в кучу. Сложность: O(log n).

        Args:
            item: Значение для вставки.
        """
        self._elements.append(item)
        self._bubble_up(len(self._elements) - 1)

    def pop(self) -> Optional[Any]:
        """
        Извлечение корневого элемента. Сложность: O(log n).

        Returns:
            Корневой элемент или None, если куча пуста.
        """
        if not self._elements:
            return None

        if len(self._elements) == 1:
            return self._elements.pop()

        root_value = self._elements[0]
        self._elements[0] = self._elements.pop()
        self._sink_down(0)
        return root_value

    def top(self) -> Optional[Any]:
        """
        Просмотр корневого элемента. Сложность: O(1).

        Returns:
            Корневой элемент или None, если куча пуста.
        """
        return self._elements[0] if self._elements else None

    def construct_from(self, input_list: List[Any]) -> None:
        """
        Построение кучи из массива. Сложность: O(n).

        Args:
            input_list: Массив для построения кучи.
        """
        self._elements = input_list.copy()
        for i in range(len(self._elements) // 2 - 1, -1, -1):
            self._sink_down(i)

    def length(self) -> int:
        """
        Получение размера кучи. Сложность: O(1).

        Returns:
            Количество элементов в куче.
        """
        return len(self._elements)

    def empty(self) -> bool:
        """
        Проверка пустоты кучи. Сложность: O(1).

        Returns:
            True, если куча пуста.
        """
        return len(self._elements) == 0

    def __str__(self) -> str:
        """Строковое представление кучи."""
        return str(self._elements)
  ```

  ### Результат выполнения

  ```bash
ХАРАКТЕРИСТИКИ ПК ДЛЯ ТЕСТИРОВАНИЯ:
- Процессор: Intel Core i7-6500U @ 2.50GHz
- Оперативная память: 8 GB
- ОС: Windows 10 PRO
- Python: 3.12.8

Демонстрация работы кучи

1. MIN-HEAP (последовательная вставка):

Вставляем 10:
Куча (min):
10

Вставляем 5:
Куча (min):
  5
╻━╹
10

Вставляем 15:
Куча (min):
  5
╻━┻━╻
10 15

Вставляем 3:
Куча (min):
    3
  ╻━┻━╻
  5   15
╻━╹
10

Вставляем 7:
Куча (min):
    3
  ╻━┻━╻
  5   15
╻━┻━╻
10  7

MIN-HEAP (извлечение):

Извлекаем 3:
Куча (min):
    5
  ╻━┻━╻
  7   15
╻━╹
10

Извлекаем 5:
Куча (min):
  7
╻━┻━╻
10 15

Извлекаем 7:
Куча (min):
 10
╻━╹
15

Извлекаем 10:
Куча (min):
15

Извлекаем 15:

2. MAX-HEAP (последовательная вставка):

Вставляем 10:
Куча (max):
10

Вставляем 5:
Куча (max):
 10
╻━╹
 5

Вставляем 15:
Куча (max):
 15
╻━┻━╻
 5 10

Вставляем 3:
Куча (max):
   15
  ╻━┻━╻
  5   10
╻━╹
 3

Вставляем 7:
Куча (max):
   15
  ╻━┻━╻
  7   10
╻━┻━╻
 3  5

MAX-HEAP (извлечение):

Извлекаем 15:
Куча (max):
   10
  ╻━┻━╻
  7    5
╻━╹
 3

Извлекаем 10:
Куча (max):
  7
╻━┻━╻
 3  5

Извлекаем 7:
Куча (max):
  5
╻━╹
 3

Извлекаем 5:
Куча (max):
 3

Извлекаем 3:

Демонстрация сортировки
Исходный массив: [9, 3, 7, 1, 8, 2, 5, 6, 4]
Отсортированный массив (heapsort): [1, 2, 3, 4, 5, 6, 7, 8, 9]
Отсортированный массив (in-place): [1, 2, 3, 4, 5, 6, 7, 8, 9]

Демонстрация приоритетной очереди
Добавление задач в очередь:
  Добавлено: "Задача A" с приоритетом 3
  Добавлено: "Задача B" с приоритетом 1
  Добавлено: "Задача C" с приоритетом 5
  Добавлено: "Задача D" с приоритетом 2
  Добавлено: "Задача E" с приоритетом 8

Извлечение задач по приоритету:
  Выполняется: "Задача B"
  Выполняется: "Задача D"
  Выполняется: "Задача A"
  Выполняется: "Задача C"
  Выполняется: "Задача E"

Построение кучи
Размер:   100 | Вставка: 0.000469 сек | Build_Heap: 0.000337 сек
Размер:   500 | Вставка: 0.001435 сек | Build_Heap: 0.001535 сек
Размер:  1000 | Вставка: 0.006659 сек | Build_Heap: 0.004194 сек
Размер:  5000 | Вставка: 0.018963 сек | Build_Heap: 0.013710 сек
Размер: 10000 | Вставка: 0.033360 сек | Build_Heap: 0.022056 сек

Сравнение алгоритмов сортировки
Размер:   100 | Heapsort: 0.001430 сек | Quicksort: 0.000701 сек | Mergesort: 0.000669 сек
Размер:   500 | Heapsort: 0.019066 сек | Quicksort: 0.006601 сек | Mergesort: 0.008869 сек
Размер:  1000 | Heapsort: 0.063956 сек | Quicksort: 0.012883 сек | Mergesort: 0.013379 сек
Размер:  2000 | Heapsort: 0.050825 сек | Quicksort: 0.008935 сек | Mergesort: 0.012414 сек
Размер:  5000 | Heapsort: 0.097000 сек | Quicksort: 0.026262 сек | Mergesort: 0.034497 сек

Время операций кучи
Размер:   100 | Вставка (средн.): 0.00001022 сек | Извлечение (средн.): 0.00002483 сек
Размер:   500 | Вставка (средн.): 0.00003114 сек | Извлечение (средн.): 0.00003882 сек
Размер:  1000 | Вставка (средн.): 0.00002029 сек | Извлечение (средн.): 0.00006419 сек
Размер:  5000 | Вставка (средн.): 0.00001278 сек | Извлечение (средн.): 0.00004013 сек
Размер: 10000 | Вставка (средн.): 0.00000972 сек | Извлечение (средн.): 0.00001999 сек

Графики сохранены в файлах:
heap_building_comparison.png
sorting_algorithms_comparison.png
heap_operations_time.png
  ```

  ## Выводы
  1. Алгоритм построения кучи методом heapify (O(n)) значительно эффективнее последовательной вставки (O(n log n)).

  2. Heapsort демонстрирует стабильную производительность O(n log n) и не требует дополнительной памяти в in-place реализации.

  3. Приоритетная очередь на основе кучи обеспечивает эффективные операции добавления и извлечения элемента с наивысшим приоритетом.

  4. Heapsort уступает QuickSort по скорости на случайных данных, но гарантирует время O(n log n) в худшем случае.

  5. Визуализация кучи в виде дерева подтвердила корректность поддержки свойства кучи после всех операций.

  ## Ответы на контрольные вопросы

  1. Какие виды куч существуют и чем они отличаются?
  - Min-Heap (корень — минимальный элемент) и Max-Heap (корень — максимальный элемент). Отличаются свойством упорядочивания.

  2. Почему кучу удобно хранить в массиве?
  - Полное бинарное дерево можно компактно представить в массиве без явных ссылок, что экономит память и ускоряет доступ.

  3. Какова сложность операции извлечения корня из кучи?
  - O(log n), так как требуется восстановление свойства кучи через операцию sift_down.

  4. В чём преимущество Heapsort перед другими алгоритмами сортировки?
  - Гарантированное время O(n log n) в худшем случае, in-place реализация, устойчивость к плохим данным.

  5. Где применяются приоритетные очереди?
  - Планирование задач, алгоритм Дейкстры, системы событий, обработка прерываний.

  6. Как работает алгоритм построения кучи за O(n)?
  - Метод heapify применяет sift_down начиная с последнего родителя, что уменьшает общее количество операций.

## Приложения
Исходный код: heap.py, heapsort.py, main.py, performance_analysis.py, visualization.py, priority_queue.py
График сравнения: heap_building_comparison.png, heap_operations_time.png, sorting_algorithms_comparison.png

![Search Comparison](heap_building_comparison.png)
![Search Comparison](heap_operations_time.png)
![Search Comparison](sorting_algorithms_comparison.png)

