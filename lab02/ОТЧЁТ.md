# Лабораторная работа 02 - Основные структуры данных

**Дата:** 22.09.2025  
**Семестр:** 3 курс, 1 семестр  
**Группа:** ПИЖ-б-о-23-2-(2)
**Дисциплина:** Алгоритмы и структуры данных  
**Студент:** Орлов Владимир Алексеевич  

## Описание проекта

Проект реализует сравнительный анализ основных структур данных (список, связный список, дек) с экспериментальным подтверждением их временной сложности для различных операций.

## Цель работы

Изучить понятие и особенности базовых абстрактных типов данных (стек, очередь, дек, связный список) и их реализаций в Python. Научиться выбирать оптимальную структуру данных для решения конкретной задачи, основываясь на анализе теоретической и практической сложности операций.

## Теоретическая часть
- **Список (list) в Python**: Реализация динамического массива. Вставка в начало - O(n), вставка в конец - O(1), удаление из начала - O(n)
- **Связный список (Linked List)**: Структура из узлов с ссылками. Вставка/удаление в начало - O(1), доступ по индексу - O(n)
- **Дек (deque)**: Двусторонняя очередь. Все операции с начала/конца - O(1)
- **Стек (Stack)**: LIFO структура. Основные операции - O(1)
- **Очередь (Queue)**: FIFO структура. Основные операции - O(1)

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализация класса LinkedList с основными операциями
- [x] Задача 2: Сравнительный анализ производительности list vs LinkedList vs deque
- [x] Задача 3: Решение практических задач (скобки, палиндром, очередь печати)
- [x] Задача 4: Визуализация результатов с построением графиков

### Ключевые фрагменты кода
```python
class SinglyLinkedList:
    """Односвязный список."""
    
    def __init__(self):
        """Инициализация пустого списка."""  # O(1) - инициализация
        self.head = None   # O(1) - присваивание
        self.tail = None   # O(1) - присваивание
        self.length = 0    # O(1) - присваивание
    
    def add_to_front(self, item):
        """
        Вставка элемента в начало списка.
        
        Args:
            item: Данные для вставки
            
        Complexity: O(1)
        """
        new_node = ListNode(item)  # O(1) - создание узла
        
        if self.head is None:      # O(1) - проверка
            self.head = new_node   # O(1) - присваивание
            self.tail = new_node   # O(1) - присваивание
        else:
            new_node.next = self.head  # O(1) - присваивание
            self.head = new_node       # O(1) - присваивание
        
        self.length += 1  # O(1) - инкремент
    
    def add_to_back(self, item):
        """
        Вставка элемента в конец списка.
        
        Args:
            item: Данные для вставки
            
        Complexity: O(1) - с использованием tail
        """
        new_node = ListNode(item)  # O(1) - создание узла
        
        if self.head is None:      # O(1) - проверка
            self.head = new_node   # O(1) - присваивание
            self.tail = new_node   # O(1) - присваивание
        else:
            self.tail.next = new_node  # O(1) - присваивание
            self.tail = new_node       # O(1) - присваивание
        
        self.length += 1  # O(1) - инкремент
    
    def remove_from_front(self):
        """
        Удаление элемента из начала списка.
        
        Returns:
            Удаленные данные или None если список пуст
            
        Complexity: O(1)
        """
        if self.head is None:      # O(1) - проверка
            return None
        
        data = self.head.data      # O(1) - доступ
        
        if self.head == self.tail: # O(1) - проверка
            self.head = None       # O(1) - присваивание
            self.tail = None       # O(1) - присваивание
        else:
            self.head = self.head.next  # O(1) - присваивание
        
        self.length -= 1  # O(1) - декремент
        return data       # O(1) - возврат

  ```

  ### Результат выполнения

  ```bash
    Характеристики ПК для тестирования:
    - Процессор: Intel Core i7-6500U @ 2.50GHz
    - Оперативная память: 8 GB
    - OC: Windows 10 PRO
    - Python: 3.12.8

Сравнение вставки в начало:
Размер | List (мс) | LinkedList (мс)
----------------------------------------
   100 |      0.04 |           0.10
   500 |      0.27 |           0.38
  1000 |      1.05 |           3.16
  2000 |      3.40 |           3.59
  5000 |     35.04 |           7.36

Сравнение удаления из начала (очередь):
Размер | List (мс) | Deque (мс)
----------------------------------------
   100 |      0.08 |       0.05
   500 |      0.24 |       0.22
  1000 |      0.69 |       0.35
  2000 |      5.67 |       1.58
  5000 |     14.90 |       3.28
  ```

  ## Выводы
  1. Связный список демонстрирует значительное преимущество при операциях вставки/удаления в начало (O(1) против O(n) у обычного списка)

  2. Дек (deque) является оптимальной структурой для реализации очереди, обеспечивая O(1) для операций с обоих концов

  3. Обычный список эффективен только для операций с концом массива и случайного доступа

  4. Для задач проверки сбалансированности скобок стек является естественным и эффективным решением

  5. Дек также эффективен для проверки палиндромов, позволяя сравнивать символы с обоих концов за O(1)

  ## Ответы на контрольные вопросы

  1. В чем ключевое отличие динамического массива (list в Python) от связного списка?
  - List: доступ по индексу O(1), вставка в начало O(n)
  - LinkedList: доступ по индексу O(n), вставка в начало O(1)

  2. Объясните принцип работы стека (LIFO) и очереди (FIFO). Примеры использования:
  - Стек (LIFO): последний пришел - первый ушел. Примеры: отмена действий, вызов функций
  - Очередь (FIFO): первый пришел - первый ушел. Примеры: очередь печати, обработка запросов

  3. Почему удаление из начала списка O(n), а из дека O(1)?
  - List требует сдвига всех элементов при удалении из начала
  - Deque использует циклический буфер, позволяющий O(1) операции с обоих концов

  4. Какую структуру выбрать для системы отмены действий?
  - Стек, так как отмена действий соответствует LIFO принципу

  5. Объясните разницу во времени вставки в начало list vs LinkedList:
  - List: O(n) из-за необходимости сдвига элементов
  - LinkedList: O(1) - просто изменение ссылок

## Приложения
Исходный код: linked_list.py, performance_analysis.py, task_solutions.py
Графики сравнения: performance_comparison.png

![Search Comparison](performance_comparison.png)

```python
#linked_list.py
class ListNode:
    """Узел связного списка."""
    
    def __init__(self, value):
        """
        Инициализация узла.
        
        Args:
            value: Данные для хранения в узле
        """
        self.data = value  # O(1) - присваивание
        self.next = None   # O(1) - присваивание


class SinglyLinkedList:
    """Односвязный список."""
    
    def __init__(self):
        """Инициализация пустого списка."""  # O(1) - инициализация
        self.head = None   # O(1) - присваивание
        self.tail = None   # O(1) - присваивание
        self.length = 0    # O(1) - присваивание
    
    def add_to_front(self, item):
        """
        Вставка элемента в начало списка.
        
        Args:
            item: Данные для вставки
            
        Complexity: O(1)
        """
        new_node = ListNode(item)  # O(1) - создание узла
        
        if self.head is None:      # O(1) - проверка
            self.head = new_node   # O(1) - присваивание
            self.tail = new_node   # O(1) - присваивание
        else:
            new_node.next = self.head  # O(1) - присваивание
            self.head = new_node       # O(1) - присваивание
        
        self.length += 1  # O(1) - инкремент
    
    def add_to_back(self, item):
        """
        Вставка элемента в конец списка.
        
        Args:
            item: Данные для вставки
            
        Complexity: O(1) - с использованием tail
        """
        new_node = ListNode(item)  # O(1) - создание узла
        
        if self.head is None:      # O(1) - проверка
            self.head = new_node   # O(1) - присваивание
            self.tail = new_node   # O(1) - присваивание
        else:
            self.tail.next = new_node  # O(1) - присваивание
            self.tail = new_node       # O(1) - присваивание
        
        self.length += 1  # O(1) - инкремент
    
    def remove_from_front(self):
        """
        Удаление элемента из начала списка.
        
        Returns:
            Удаленные данные или None если список пуст
            
        Complexity: O(1)
        """
        if self.head is None:      # O(1) - проверка
            return None
        
        data = self.head.data      # O(1) - доступ
        
        if self.head == self.tail: # O(1) - проверка
            self.head = None       # O(1) - присваивание
            self.tail = None       # O(1) - присваивание
        else:
            self.head = self.head.next  # O(1) - присваивание
        
        self.length -= 1  # O(1) - декремент
        return data       # O(1) - возврат
    
    def collect_all(self):
        """
        Обход всех элементов списка.
        
        Returns:
            Список всех элементов
            
        Complexity: O(n)
        """
        result = []            # O(1) - создание списка
        current = self.head    # O(1) - присваивание
        
        while current:         # O(n) - цикл по всем элементам
            result.append(current.data)  # O(1) - добавление в список
            current = current.next       # O(1) - переход к следующему
        
        return result  # O(1) - возврат
    
    def empty_check(self):
        """
        Проверка пустоты списка.
        
        Returns:
            True если список пуст, иначе False
            
        Complexity: O(1)
        """
        return self.head is None  # O(1) - проверка


# Общая сложность класса: зависит от вызываемых методов
```

```python
#performance_analysis.py
import timeit
import matplotlib.pyplot as plt
from collections import deque
from linked_list import LinkedList


def time_insert_front_list(n):
    """
    Измерение времени вставки в начало списка.
    
    Args:
        n: Количество элементов для вставки
        
    Returns:
        Время выполнения в миллисекундах
    """
    def operation():
        lst = []  # O(1) - создание списка
        for i in range(n):  # O(n) - цикл
            lst.insert(0, i)  # O(n) - вставка в начало
    
    time_taken = timeit.timeit(operation, number=1)  # O(n^2) - общая сложность
    return time_taken * 1000  # O(1) - умножение


def time_insert_front_linked(n):
    """
    Измерение времени вставки в начало связного списка.
    
    Args:
        n: Количество элементов для вставки
        
    Returns:
        Время выполнения в миллисекундах
    """
    def operation():
        ll = LinkedList()  # O(1) - создание списка
        for i in range(n):  # O(n) - цикл
            ll.insert_at_start(i)  # O(1) - вставка в начало
    
    time_taken = timeit.timeit(operation, number=1)  # O(n) - общая сложность
    return time_taken * 1000  # O(1) - умножение


def time_remove_front_list(n):
    """
    Измерение времени удаления из начала списка.
    
    Args:
        n: Количество операций удаления
        
    Returns:
        Время выполнения в миллисекундах
    """
    def operation():
        lst = list(range(n))  # O(n) - создание списка
        for _ in range(n):  # O(n) - цикл
            if lst:  # O(1) - проверка
                lst.pop(0)  # O(n) - удаление из начала
    
    time_taken = timeit.timeit(operation, number=1)  # O(n^2) - общая сложность
    return time_taken * 1000  # O(1) - умножение


def time_remove_front_deque(n):
    """
    Измерение времени удаления из начала дека.
    
    Args:
        n: Количество операций удаления
        
    Returns:
        Время выполнения в миллисекундах
    """
    def operation():
        dq = deque(range(n))  # O(n) - создание дека
        for _ in range(n):  # O(n) - цикл
            if dq:  # O(1) - проверка
                dq.popleft()  # O(1) - удаление из начала
    
    time_taken = timeit.timeit(operation, number=1)  # O(n) - общая сложность
    return time_taken * 1000  # O(1) - умножение


def execute_performance_benchmark():
    """Запуск анализа производительности."""
    # Характеристики ПК для тестирования
    pc_info = """
    Характеристики ПК для тестирования:
    - Процессор: Intel Core i7-6500U @ 2.50GHz
    - Оперативная память: 8 GB
    - OC: Windows 10 PRO
    - Python: 3.12.8
    """
    print(pc_info)
    
    # Тестируемые размеры
    test_sizes = [100, 500, 1000, 2000, 5000]
    
    # Результаты измерений
    list_insert_data = []
    linked_insert_data = []
    list_pop_data = []
    deque_pop_data = []
    
    print('Сравнение вставки в начало:')
    print('Размер | List (мс) | LinkedList (мс)')
    print('-' * 40)
    
    for size in test_sizes:
        list_time = time_insert_front_list(size)
        linked_time = time_insert_front_linked(size)
        
        list_insert_data.append(list_time)
        linked_insert_data.append(linked_time)
        
        print(f'{size:6} | {list_time:9.2f} | {linked_time:14.2f}')
    
    print('\nСравнение удаления из начала (очередь):')
    print('Размер | List (мс) | Deque (мс)')
    print('-' * 40)
    
    for size in test_sizes:
        list_time = time_remove_front_list(size)
        deque_time = time_remove_front_deque(size)
        
        list_pop_data.append(list_time)
        deque_pop_data.append(deque_time)
        
        print(f'{size:6} | {list_time:9.2f} | {deque_time:10.2f}')
    
    # Построение графиков
    plt.figure(figsize=(12, 5))
    
    # График 1: Сравнение вставки в начало
    plt.subplot(1, 2, 1)
    plt.plot(test_sizes, list_insert_data, 'ro-', label='List insert(0)')
    plt.plot(test_sizes, linked_insert_data, 'bo-', label='LinkedList insert_at_start')
    plt.xlabel('Количество элементов')
    plt.ylabel('Время (мс)')
    plt.title('Вставка в начало\nList: O(n²) vs LinkedList: O(n)')
    plt.legend()
    plt.grid(True)
    
    # График 2: Сравнение удаления из начала
    plt.subplot(1, 2, 2)
    plt.plot(test_sizes, list_pop_data, 'ro-', label='List pop(0)')
    plt.plot(test_sizes, deque_pop_data, 'go-', label='Deque popleft()')
    plt.xlabel('Количество элементов')
    plt.ylabel('Время (мс)')
    plt.title('Удаление из начала\nList: O(n²) vs Deque: O(n)')
    plt.legend()
    plt.grid(True)
    
    plt.tight_layout()
    plt.savefig('performance_comparison.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    return {
        'sizes': test_sizes,
        'list_insert': list_insert_data,
        'linked_list_insert': linked_insert_data,
        'list_dequeue': list_pop_data,
        'deque_dequeue': deque_pop_data
    }


if __name__ == '__main__':
    benchmark_results = execute_performance_benchmark()
```

```python
#task_solutions.py
from collections import deque


def validate_brackets(expression):
    """
    Проверка сбалансированности скобок с использованием стека.
    
    Args:
        expression: Строка со скобками
        
    Returns:
        True если скобки сбалансированы, иначе False
        
    Complexity: O(n)
    """
    stack = []  # O(1) - создание стека
    bracket_pairs = {')': '(', ']': '[', '}': '{'}  # O(1) - создание словаря
    
    for char in expression:  # O(n) - цикл по символам
        if char in '([{':  # O(1) - проверка
            stack.append(char)  # O(1) - добавление в стек
        elif char in bracket_pairs:  # O(1) - проверка
            if not stack or stack[-1] != bracket_pairs[char]:  # O(1) - проверка
                return False  # O(1) - возврат
            stack.pop()  # O(1) - удаление из стека
    
    return len(stack) == 0  # O(1) - проверка и возврат


def check_palindrome_with_deque(text):
    """
    Проверка строки на палиндром с использованием дека.
    
    Args:
        text: Строка для проверки
        
    Returns:
        True если строка - палиндром, иначе False
        
    Complexity: O(n)
    """
    # Очистка строки от пробелов и приведение к нижнему регистру
    cleaned = ''.join(char.lower() for char in text if char.isalnum())  # O(n)
    
    dq = deque(cleaned)  # O(n) - создание дека
    
    while len(dq) > 1:  # O(n) - цикл
        if dq.popleft() != dq.pop():  # O(1) - сравнение
            return False  # O(1) - возврат
    
    return True  # O(1) - возврат


class DocumentPrintQueue:
    """Очередь печати на основе deque."""
    
    def __init__(self):
        """Инициализация очереди."""  # O(1) - инициализация
        self.print_jobs = deque()  # O(1) - создание дека
    
    def submit_job(self, document):
        """
        Добавление задачи в очередь.
        
        Args:
            document: Документ для печати
            
        Complexity: O(1)
        """
        self.print_jobs.append(document)  # O(1) - добавление в конец
    
    def next_job(self):
        """
        Извлечение задачи из очереди.
        
        Returns:
            Документ или None если очередь пуста
            
        Complexity: O(1)
        """
        if self.print_jobs:  # O(1) - проверка
            return self.print_jobs.popleft()  # O(1) - удаление из начала
        return None  # O(1) - возврат
    
    def execute_all_jobs(self):
        """
        Обработка всех задач в очереди.
        
        Complexity: O(n)
        """
        print('Обработка очереди печати:')
        while self.print_jobs:  # O(n) - цикл
            job = self.next_job()  # O(1) - извлечение
            print(f'Печатается: {job}')  # O(1) - вывод
        print('Все задачи обработаны.')  # O(1) - вывод
    
    def has_no_jobs(self):
        """
        Проверка пустоты очереди.
        
        Returns:
            True если очередь пуста, иначе False
            
        Complexity: O(1)
        """
        return len(self.print_jobs) == 0  # O(1) - проверка


def run_practical_examples():
    """Тестирование практических задач."""
    # Тест проверки скобок
    sample_expressions = [
        '()',
        '()[]{}',
        '([{}])',
        '(]',
        '([)]',
        '((()'
    ]
    
    print('Проверка сбалансированности скобок:')
    for expr in sample_expressions:
        result = validate_brackets(expr)
        print(f'"{expr}" -> {"Сбалансированы" if result else "Не сбалансированы"}')
    
    print('\n' + '='*50 + '\n')
    
    # Тест проверки палиндромов
    sample_texts = [
        'А роза упала на лапу Азора',
        'racecar',
        'hello',
        'Madam, I\'m Adam',
        'not a palindrome'
    ]
    
    print('Проверка палиндромов:')
    for text in sample_texts:
        result = check_palindrome_with_deque(text)
        print(f'"{text}" -> {"Палиндром" if result else "Не палиндром"}')
    
    print('\n' + '='*50 + '\n')
    
    # Тест очереди печати
    print('Симуляция очереди печати:')
    job_queue = DocumentPrintQueue()
    
    # Добавляем задачи в очередь
    documents = ['Документ1.pdf', 'Отчет.docx', 'Презентация.pptx', 'Изображение.jpg']
    for doc in documents:
        job_queue.submit_job(doc)
        print(f'Добавлено в очередь: {doc}')
    
    print()
    job_queue.execute_all_jobs()


if __name__ == '__main__':
    run_practical_examples()
```
  