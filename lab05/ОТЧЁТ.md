# Лабораторная работа 05 - Хеш-функции и хеш-таблицы

**Дата:** 22.09.2025  
**Семестр:** 3 курс, 1 семестр  
**Группа:** ПИЖ-б-о-23-1-(1)
**Дисциплина:** Алгоритмы и структуры данных  
**Студент:** Орлов Владимир Алексеевич  

## Описание проекта

Проект реализует различные хеш-функции и методы разрешения коллизий в хеш-таблицах. Проведен сравнительный анализ эффективности разных методов при различных коэффициентах заполнения.

## Цель работы

Изучить принципы работы хеш-функций и хеш-таблиц. Освоить методы разрешения коллизий. Получить практические навыки реализации хеш-таблицы с различными стратегиями разрешения коллизий. Провести сравнительный анализ эффективности разных методов.

## Теоретическая часть
- **Хеш-функция**: Функция, преобразующая произвольные данные в данные фиксированного размера (хеш-код)
- **Хеш-таблица**: Структура данных, реализующая ассоциативный массив с операциями O(1) в среднем случае
- **Коллизия**: Ситуация, когда разные ключи имеют одинаковый хеш-код
- **Метод цепочек**: Каждая ячейка таблицы содержит список элементов с одинаковым хешем
- **Открытая адресация**: Все элементы хранятся в самом массиве, при коллизии ищется следующая свободная ячейка
- **Двойное хеширование**: Метод открытой адресации, использующий вторую хеш-функцию для определения шага probing


## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализация 3 хеш-функций для строковых ключей
- [x] Задача 2: Реализация хеш-таблицы с методом цепочек
- [x] Задача 3: Реализация хеш-таблицы с открытой адресацией (линейное пробирование и двойное хеширование)
- [x] Задача 4: Сравнительный анализ эффективности разных методов разрешения коллизий
- [x] Задача 5: Исследование влияния коэффициента заполнения на производительность


### Ключевые фрагменты кода
```python
def hash_polynomial(key: str, table_size: int, base: int = 31) -> int:
    """
    Полиномиальная хеш-функция.

    Args:
        key: Строковый ключ
        table_size: Размер хеш-таблицы
        base: Основание полинома

    Returns:
        Хеш-значение в диапазоне [0, table_size-1]
    """
    hash_code = 0
    for symbol in key:
        hash_code = (hash_code * base + ord(symbol)) % table_size
    return hash_code

class ChainingHashTable:
    """Хеш-таблица с методом цепочек для разрешения коллизий."""

    def __init__(self, initial_capacity: int = 101, hash_method: str = 'simple', 
                 max_load_factor: float = 0.7):
        """
        Инициализация хеш-таблицы.

        Args:
            initial_capacity: Начальный размер таблицы (простое число)
            hash_method: Используемая хеш-функция ('simple', 'polynomial', 'djb2')
            max_load_factor: Порог для рехеширования
        """
        self.capacity = initial_capacity
        self.elements_count = 0
        self.load_threshold = max_load_factor
        self.buckets = [[] for _ in range(initial_capacity)]

        # Выбор хеш-функции
        hash_algorithms = {
            'simple': simple_hash,
            'polynomial': polynomial_hash,
            'djb2': djb2_hash
        }
        self._hash_algorithm = hash_algorithms[hash_method]

class OpenAddressingHashTable:
    """Хеш-таблица с открытой адресацией."""

    def __init__(self, initial_size: int = 101, hash_method: str = 'simple',
                 probing: str = 'linear', load_factor: float = 0.7):
        """
        Инициализация хеш-таблицы.

        Args:
            initial_size: Начальный размер таблицы (простое число)
            hash_method: Используемая хеш-функция
            probing: Метод пробирования ('linear', 'double')
            load_factor: Порог коэффициента заполнения
        """
        self.capacity = initial_size
        self.active_items = 0
        self.removed_items = 0
        self.load_threshold = load_factor
        self.probe_strategy = probing
        self.slots = [OpenAddressingEntry() for _ in range(initial_size)]

        # Выбор хеш-функции
        hash_algorithms = {
            'simple': simple_hash,
            'polynomial': polynomial_hash,
            'djb2': djb2_hash
        }
        self._hash_algorithm = hash_algorithms[hash_method]
  ```

  ### Результат выполнения

  ```bash
Запуск анализа производительности...
Size: 100, Load: 0.1, Impl: Chaining      
  Insert: 0.000000s, Search: 0.000000s    
  Collisions: 0
Size: 100, Load: 0.1, Impl: Linear Probing
  Insert: 0.000000s, Search: 0.000000s    
  Collisions: 0
Size: 100, Load: 0.1, Impl: Double Hashing
  Insert: 0.000000s, Search: 0.000000s    
  Collisions: 0
Size: 100, Load: 0.5, Impl: Chaining      
  Insert: 0.000000s, Search: 0.000000s    
  Collisions: 7
Size: 100, Load: 0.5, Impl: Linear Probing
  Insert: 0.000457s, Search: 0.000000s
  Collisions: 7
Size: 100, Load: 0.5, Impl: Double Hashing
  Insert: 0.000998s, Search: 0.000000s
  Collisions: 7
Size: 100, Load: 0.7, Impl: Chaining
  Insert: 0.000000s, Search: 0.000000s
  Collisions: 21
Size: 100, Load: 0.7, Impl: Linear Probing
  Insert: 0.000344s, Search: 0.000000s
  Collisions: 28
Size: 100, Load: 0.7, Impl: Double Hashing
  Insert: 0.000999s, Search: 0.000998s
  Collisions: 12
Size: 100, Load: 0.9, Impl: Chaining
  Insert: 0.000993s, Search: 0.000000s
  Collisions: 12
Size: 100, Load: 0.9, Impl: Linear Probing
  Insert: 0.006482s, Search: 0.000000s
  Collisions: 16
Size: 100, Load: 0.9, Impl: Double Hashing
  Insert: 0.015679s, Search: 0.000000s
  Collisions: 10
Size: 500, Load: 0.1, Impl: Chaining
  Insert: 0.000997s, Search: 0.000000s
  Collisions: 4
Size: 500, Load: 0.1, Impl: Linear Probing
  Insert: 0.000000s, Search: 0.000000s
  Collisions: 4
Size: 500, Load: 0.1, Impl: Double Hashing
  Insert: 0.000994s, Search: 0.000000s
  Collisions: 4
Size: 500, Load: 0.5, Impl: Chaining
  Insert: 0.002000s, Search: 0.001004s
  Collisions: 82
Size: 500, Load: 0.5, Impl: Linear Probing
  Insert: 0.031915s, Search: 0.025082s
  Collisions: 110
Size: 500, Load: 0.5, Impl: Double Hashing
  Insert: 0.002857s, Search: 0.001999s
  Collisions: 89
Size: 500, Load: 0.7, Impl: Chaining
  Insert: 0.001969s, Search: 0.000997s
  Collisions: 159
Size: 500, Load: 0.7, Impl: Linear Probing
  Insert: 0.131382s, Search: 0.081781s
  Collisions: 221
Size: 500, Load: 0.7, Impl: Double Hashing
  Insert: 0.007943s, Search: 0.008976s
  Collisions: 185
Size: 500, Load: 0.9, Impl: Chaining
  Insert: 0.005985s, Search: 0.002992s
  Collisions: 227
Size: 500, Load: 0.9, Impl: Linear Probing
  Insert: 0.219411s, Search: 0.110059s
  Collisions: 345
Size: 500, Load: 0.9, Impl: Double Hashing
  Insert: 0.019948s, Search: 0.011967s
  Collisions: 239
Size: 1000, Load: 0.1, Impl: Chaining
  Insert: 0.000998s, Search: 0.000997s
  Collisions: 21
Size: 1000, Load: 0.1, Impl: Linear Probing
  Insert: 0.000997s, Search: 0.000996s
  Collisions: 26
Size: 1000, Load: 0.1, Impl: Double Hashing
  Insert: 0.001996s, Search: 0.000997s
  Collisions: 22
Size: 1000, Load: 0.5, Impl: Chaining
  Insert: 0.002992s, Search: 0.003989s
  Collisions: 277
Size: 1000, Load: 0.5, Impl: Linear Probing
  Insert: 0.199620s, Search: 0.107558s
  Collisions: 363
Size: 1000, Load: 0.5, Impl: Double Hashing
  Insert: 0.021460s, Search: 0.004958s
  Collisions: 280
Size: 1000, Load: 0.7, Impl: Chaining
  Insert: 0.000997s, Search: 0.000997s
  Collisions: 442
Size: 1000, Load: 0.7, Impl: Linear Probing
  Insert: 0.271177s, Search: 0.331115s
  Collisions: 571
Size: 1000, Load: 0.7, Impl: Double Hashing
  Insert: 0.035904s, Search: 0.014963s
  Collisions: 447
Size: 1000, Load: 0.9, Impl: Chaining
  Insert: 0.009972s, Search: 0.004986s
  Collisions: 610
Size: 1000, Load: 0.9, Impl: Linear Probing
  Insert: 1.038105s, Search: 0.549530s
  Collisions: 732
Size: 1000, Load: 0.9, Impl: Double Hashing
  Insert: 0.048871s, Search: 0.015954s
  Collisions: 610
  ```

  ## Выводы
  1. Метод цепочек демонстрирует стабильную производительность даже при высоких коэффициентах заполнения (0.9). Время операций увеличивается плавно, что делает его надежным выбором для приложений с переменной нагрузкой.

  2. Открытая адресация с линейным пробированием показывает хорошую производительность при низких коэффициентах заполнения (<0.7), но значительно замедляется при высоких нагрузках из-за кластеризации.

  3. Двойное хеширование обеспечивает лучшее распределение элементов по сравнению с линейным пробированием, что снижает количество коллизий и улучшает производительность при высоких коэффициентах заполнения.

  4. Влияние коэффициента заполнения существенно для всех методов, но наиболее критично для открытой адресации. Рекомендуется поддерживать коэффициент заполнения ≤0.7 для открытой адресации и ≤0.9 для метода цепочек.

  5. Сравнение хеш-функций показало, что DJB2 обеспечивает наилучшее распределение с минимальным количеством коллизий, за ней следует полиномиальная хеш-функция. Простая хеш-функция подвержена коллизиям для похожих ключей.

  6. Временная сложность подтверждена экспериментально: O(1) для операций в среднем случае при правильном выборе коэффициента заполнения и хеш-функции.

  ## Ответы на контрольные вопросы

  1. Какие методы разрешения коллизий наиболее эффективны и в каких случаях?
  - Метод цепочек: для приложений с переменной нагрузкой и высокими коэффициентами заполнения
  - Открытая адресация: когда важна эффективность использования памяти и предсказуемость доступа
  - Двойное хеширование: для минимизации кластеризации и улучшения распределения

  2. Как коэффициент заполнения влияет на производительность хеш-таблиц?
  - Метод цепочек: плавное снижение производительности до коэффициента 0.9
  - Открытая адресация: резкое снижение производительности после коэффициента 0.7
  - Критический порог: 0.7 для открытой адресации, 0.9 для метода цепочек

  3. В чем преимущество метода цепочек перед открытой адресацией?
  - Более устойчив к высоким коэффициентам заполнения
  - Проще в реализации и отладке
  - Не требует сложной логики пробирования
  - Легко удаляет элементы

  4. Когда следует использовать двойное хеширование вместо линейного пробирования?
  - При высоких требованиях к производительности
  - Когда ожидается высокий коэффициент заполнения
  - Для минимизации эффекта кластеризации
  - В системах, где важна предсказуемость времени доступа

  5. Как выбрать хорошую хеш-функцию для строковых ключей?
  - DJB2: обеспечивает хорошее распределение и быстрое вычисление
  - Полиномиальная: хороший баланс между скоростью и качеством распределения
  - Критерии выбора: равномерность распределения, скорость вычисления, минимальность коллизий

## Приложения
Исходный код: hash_functions.py, hash_table_chaining.py, hash_table_open_addressing.py, test_hash_tables.py, performance_analysis.py
График сравнения: performance_results.png

![Search Comparison](performance_results.png)


